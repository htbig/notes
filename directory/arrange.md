# iot
* 物联网套件的选择:微软和阿里百度等
```
1 地域选择:阿里百度国内,微软国外,到后来需要用到微软时候确实也发现微软的很多iot功能都是在国际分支有实现,中国版没有的.
2 业务重点:微软和百度重点都在数据采集后的存储,分析,展现.以及对数据的分析,人工智能为重点,重点不在接入;阿里的物联网套
件重点一是设备接入,二是数据的导出
3 数据安全性:微软和阿里都是采用ssl加密才能云端和设备端通信,百度不强制.特别阿里要求更高,一定要ssl版本为TLSV1.1 或 
TLSV1.2 版本.
```
* 物联网套件协议选择:mqtt.https.amqp.coap(仅支持udp协议,且仅仅华东2上海地区支持coap)
```
阿里iot支持mqtt/coap/http,其中只有mqtt支持远程控制设备;
且mqtt是基于tcp/ip协议栈的异步通信消息协议,适用于设备硬件存储有限,或者网络不稳定的情况,阿里iot且在原生mqtt topic基础上实现了rrpc(Revert Remote Procedure Call)同步通讯方式,
微软是derict method方式.
还支持http协议,https保证通道安全,它只适合单纯的数据上报场景,显然不适合我们需要S2D的场景
```
* 何为nb-iot
```
Narrow Band Internet of Things, NB-IoT
```
* 何为websocket
```
平时使用的http协议,只能客户端发起,服务端无法主动向客户端发起请求,websocket就是为解决这个而产生.websocket协议客户端,服务端都可主动推送信息,可以文本或者二进制文件
```
* node js/pyhton
```
node 安装模块用npm install
python安装模块用pip install 
```
* 如何保证数据安全ssl(secure socket layer)/tsl(transport secure layer) 协议知识
```
加密证书:可以将明文散列出一段文字(MD5或者sha),然后再利用私钥对这段文字加密就可以得到证书;

```
* 如何处理网络压力
```
负载均衡方式1:基于特定服务器软件的负载均衡,http支持location,2:基于dns负载均衡,对于同一个域名配置多个不同的地址,最终查询这个名字的域名得到其中一个地址
访问不同服务器达到负载均衡3:反向代理负载均衡,代理服务器将请求均匀的发送给内部web服务器,不会出现负载在某个内部服务器特别集中的现象,缺点代理服务器成为了
瓶颈4:基于NAT(网络地址转发)负载均衡技术;
nigix利用upstream机制,利用反向代理方式运行,将客户端的web请求根据一定规则发送给后端不同的服务器上去处理
```
* 容灾性
```
当系统遭受到外界破坏是能及时切换到系统的备份系统.能够提供系统恢复功能.
```
* beego开源框架实现告警模块
```
go语言实现,MVC架构,开发文档多,详细.数据库选择sqlite
op_id用于计数,实现云端和设备端大小比较获得同步状态,se_id用来记录同样告警的流水信息.
需要告警信息表,操作记录表,流水表等,
```
* 如何防止时刻时刻很多告警同时上报上来问题
```
两方面考虑,1:从告警源头来解决,如果有告警上报消失频率高,说明告警产生模块编写就不太正常,做出修改;设备端的告警模块也会做筛选,如果该告警已经上报过,存在设备端
数据库,是不会重复上报给云端的
2:设备端发送到云端接受都是按照顺序接受的,所以一般不会出现不同步,除非是一条告警还没结束处理(即op_id还没有+1),下一条同设备的
告警就上报上来了(这种属于设备端发送告警频率过于频繁,需要修改上报告警的模块);
```
* Django框架
```
python实现,处理高请求问题,数据库同步,可以采用乐观锁,乐观锁并不是真正的锁,而是在更新数据库之前查询数据库数据是否是之前查询到的值,否则不更新数据库;
命令:1 django-admin startproject project_name创建工程2:python manage.py startapp app_name新建app3:python manage.py makemigrations创建更改文件,
会生成py文件4:python manage.py migrate将生成的py文件应用的数据库5:python manage.py runserver 0.0.0.0:8000启动服务6:python manage.py createsuperuser创建
用户7:python manage.py dbshell进入数据库8:python manage.py可以看到更多命令
```
* 告警及事件
```
告警比如摄像头离线,上线后告警消失
告警事件比如门锁打开失败,不存在这次门锁打开成功,告警消失,定问事件
```
* 几种关系数据库对比
```
分布式数据库结和数据库技术和网络技术的产物，由一组数据组成
这组数据分布在不同计算机上那个节点通过网络
有独立处理能力，成为场地自治，可以执行局部
应用，也可以通过网络通信子系统执行全局应用
，分布式数据库中的数据相对于用户透明
数据库备份分为物理备份和逻辑备份，物理备份就是操作系统
层面对数据文件进行备份，冷备份和热备份，冷备份是将
数据库正常关闭，在停止状态下利用copy cp tar 
cpio等命令将数据库文件备份下来，当数据库发生
故障时，拷贝回来，进行恢复，热备份也分为
两种，一种不关闭数据库，将数据库中需要备份的数据文件
依次次至于备份状态，相对保持静止，然后copy cp tar cpio将文件备份下来
备份完毕再将数据文件恢复为正常状态，另一种
方式是利用备份软件在数据库正常运行状态下
将数据库文件备份出来
逻辑备份是利用各数据库系统自带工具软件备份和恢复数据库内容
sqlite基于文件的数据库,很好迁移性,不需要port socket交互,没有用户管理，
数据库和文件系统差别（acld），1:易用性，查找方便2:保证数据的完整正确有效一致3:并发控制好，4:数据的持久性（比如统计一个班上分数80份以上的，如何文件系统，你得
自己写代码分析，数据库直接用就好）

```
* app管理
```
所有服务启动关闭systemctl控制,包的安装dpkg -i或者pm install -r,不同类型的设备会有一个软件版本table,有不同运行软件,所以会上线拿到设备类型及软件列表,
且存放到本地json文件,且启动不同服务,如果软件控制服务启动是网络没通,会先从设备上json文件load配置启动不同服务.软件版本通过wget到本地安装;界面可以完全控制设备
上的软件模块开启关闭,除了涉及设备上线的重点服务不允许管理员操作,以免误操作.
```
* gitlab ci/cd
```
软件版本持续集成和持续交付,持续以为随时可运行,不代表一直运行,持续集成就是代码的变更后自动检测,拉取,构建和进行单元测试的过程;持续交付是指整个流程链,
它自动检测代码变动并通过构建,测试,打包和相关操作运行他们以生成可部署的版本,基本没有人为干涉,持续交付在软件中目标是自动化,效率,可靠性,可重复性和质量保证.
我们应用中是提交代码,触发编译deb包,如果修改代码的特定文件即为发布release版本,并将版本包上传了文件服务器供升级用.
gitlab-runner跑在编译版本服务器上，运行注册到gitlab服务器，在gitlab工程编写.gitlab-ci.yml文件，且设置中ci/cd选择gitlab-runner,完成整个持续交付
流程。
```
* 全链路状态监控
```
服务端通过ping/pong检查服务正确性,设备端是服务定时查询设备在线情况,不在线发起重连.
```
* 内存
```
虚拟内存都是offset，根据selector查gdt得到base address,然后加上offset变成Linear地址，再经过mmu转换变成实际物理地址。
KERBASE为0xf0000000，到0xffffffff有256M，给内核使用，ULIM为0xef800000，以上的地址用户无法访问，kernel可以读写。UTOP为0xeec00000，在UTOP和ULIM之间
的空间内核和用户都只能读不能写。共12M，方内核的一些只读结构。在UTOP以下的给用户用的。
envs 设定1024个，1左移动10位
所有的envs都放在env_free_list，curenv表示当前运行的用户程序，刚boot起来他位NULL ,UVPT为ULIM减4M放env 自己的page table
256个中断异常描述项在中断描述表其实地址放在（IDT寄存器里），0-31的中断，Intel自己预留，当发生中断或者异常时,cpu根据中断向量索引找到中断处理函数的地址
T_SYSCALL 48位系统调用中断
中断向量到中断地址过程:用户发生中断,cpu会根据IDT找到中断描述表的地址,在根据中断矢量(中断号)找到中断门描述符,在根据里面的段选择子在GDT中找到基地址,
再加上偏移地址,就得到中断处理函数的地址.
中断处理函数执行前,得找到一个地方存放中断发生前的一些寄存器状态信息,如EIP,CS等,这样中断处理完可以继续中断前的地方执行.这个区域不能被用户程序访问到,
所以x86遇到用户中断从用户态到内核态时,会将堆栈也切换到内核栈;tss就是存放这个堆栈位置的结构,包括堆栈的段选择子和地址等;
发生特权级别切换是,切换到内核栈后,cpu会将SS, ESP, EFLAGS, CS, EIP压栈,并且将中断门描述符中对应的值放到CS, EIP,并且赋值正确的ESP和SS指向新的栈.
TSS的ESP0和SS0设置为内核栈地址
cpu可以处理来自用户态和内核态的中断或者异常,内核态发生中断/异常,不需要切换堆栈,只需要push  EFLAGS, CS, EIP的值,不需要SS和ESP的值;
jos中用int $30触发cpu中断完成系统调用:如果为系统调用会调用lib/syscall.c下传入不同的syscall_no(%eax存放)其他参数分别用%edx, %ecx, %ebx, %edi, 和%esi
保存,不同的trap也有不同的trap_no,进入内核栈,组件trap_frame之后调用trap函数来根据不同的trap_no,分配给不同的处理函数去执行.如果是系统调用kern/syscall.c
的syscall根据不同的syscall_no调用不同的函数实现,结果通过寄存器eax返回给用户态
```
* smp
```
symmetric multiprocessing,指所有处理器地位是对等的,包括内存对称和IO对称,虽然对等,但是他们也分为bsp处理器(负责初始化其他cpu)和ap处理器,至于哪个是bsp由
bios决定.
Advanced Programmable Interrupt Controller(高级可编程中断控制器)分为两个单元:LAPIC和IO APIC,他们通过ICC相连.作用1:减轻内存总线关于中断向量流量,
2:可以在多处理器里面分担中断处理负载.LAPIC提供interprocessor interrupts (IPIs),允许任意处理器中断其他处理器或者设置其他处理器，有好几种类型的IPIs，
如INIT IPIs和STARTUP IPIs,LAPIC和IO APIC可以是独立的芯片,也可以将LAPIC和CPU放在同一个芯片里.
在SMP系统中,每个CPU伴随着一个LAPIC单元,用于传递和响应系统中断,也为与相连的CPU提供了唯一的ID
MMIOBASE(0xef800000)开始溜了4M给MMIO使用
bsp cpu将apentry的汇编拷贝到MPENTRY_PADDR（0x7000）,然后告诉汇编里面每个cpu用什么堆栈，然后向每个ap发送ipi中断，告诉他entry.s的地址去执行，类似
boot.s，最后调用到mp_main，最后将cpu状态设置为CPU_STARTED；这样boot_aps就可以退出while循环继续初始化下一个cpu
多cpu工作同时进内核，采用大锁，只能一个cpu运行在内核态，
```
* ACID
```
在可靠数据库管理系统中，事务具备的4个属性原子性，一致性，隔离性，持久性。
```
* linux运行exe
```
wget http://download.microsoft.com/download/1/1/1/1116b75a-9ec3-481a-a3c8-1777b5381140/vcredist_x86.exe
```
